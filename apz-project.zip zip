pipefail

OUT_ZIP="${1:-apz-project.zip}"
ROOT="${2:-./apz-project}"

echo "Creating full APZ repo scaffold at $ROOT"
rm -rf "$ROOT"
mkdir -p "$ROOT"

# create dirs
dirs=(
  ".github/workflows"
  "infra/docker"
  "infra/helm/node/templates"
  "infra/helm/indexer/templates"
  "infra/helm/api/templates"
  "infra/devnet"
  "scripts"
  "contracts"
  "contracts/test"
  "apps/api/src"
  "apps/indexer/src"
  "apps/web/pages/api"
  "apps/web/pages"
  "apps/web"
  "priv"
  "docs"
  "systemd"
)
for d in "${dirs[@]}"; do mkdir -p "$ROOT/$d"; done

# helper to write files
write() {
  local path="$1"; shift
  mkdir -p "$(dirname "$ROOT/$path")"
  cat > "$ROOT/$path" <<'EOF'
'"$@"'
EOF
}

# Write files (using here-documents with correct contents)

cat > "$ROOT/.gitignore" <<'GI'
node_modules
*.zip
.env
GI

cat > "$ROOT/README.md" <<'MD'
# APZ Chain - Repository

This repository contains infra, charts, scripts and specs to run APZ Chain devnet/testnet/mainnet.

Quick start:
1. Configure secrets and registry envs.
2. Build and push images using GitHub Actions (see .github/workflows).
3. Run scripts/bootstrap-all.sh to install charts into target cluster.

See /docs for runbooks, security policies and validator onboarding details.
MD

cat > "$ROOT/genesis.json" <<'JSON'
{
  "chain_id": "apz-testnet-1",
  "genesis_time": "2025-10-17T00:00:00Z",
  "consensus_params": {
    "block": { "max_bytes": "22020096", "max_gas": "-1", "time_iota_ms": "1000" },
    "evidence": { "max_age_num_blocks": "100000", "max_age_duration": "172800000000000" },
    "validator": { "pub_key_types": ["ed25519"] }
  },
  "validators": [],
  "app_state": {
    "bank": {
      "balances": []
    },
    "staking": {
      "params": { "unbonding_time": "1814400000000000", "max_validators": 100 }
    },
    "gov": {
      "deposit_params": { "min_deposit": [{ "denom": "apz", "amount": "1000000000000000000" }] }
    },
    "supply": { "total": [{ "denom": "apz", "amount": "1000000000000000000000000000" }] }
  }
}
JSON

# OpenAPI
cat > "$ROOT/openapi.yaml" <<'YAML'
openapi: "3.0.0"
info:
  title: APZ API
  version: "0.1.0"
servers:
  - url: https://api.apz.example
paths:
  /auth/challenge-request:
    post:
      summary: Request wallet challenge
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                wallet_address:
                  type: string
      responses:
        '200':
          description: challenge returned
          content:
            application/json:
              schema:
                type: object
                properties:
                  challenge:
                    type: string
  /auth/wallet-verify:
    post:
      summary: Verify signature and issue JWT
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                wallet_address:
                  type: string
                signature:
                  type: string
      responses:
        '200':
          description: auth token
          content:
            application/json:
              schema:
                type: object
                properties:
                  token:
                    type: string
YAML

# Dockerfiles
cat > "$ROOT/infra/docker/node.Dockerfile" <<'DOCKERNODE'
FROM golang:1.20-alpine AS builder
WORKDIR /src
RUN apk add --no-cache git build-base
COPY ./node-client /src
RUN go mod download
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o /bin/apz-node ./cmd/node

FROM alpine:3.18
RUN apk add --no-cache ca-certificates
COPY --from=builder /bin/apz-node /usr/local/bin/apz-node
ENV APZ_HOME=/var/lib/apz
VOLUME ["/var/lib/apz"]
EXPOSE 26656 26657 1317
ENTRYPOINT ["apz-node"]
CMD ["start"]
DOCKERNODE

cat > "$ROOT/infra/docker/indexer.Dockerfile" <<'DOCKERINDEX'
FROM node:18-alpine AS builder
WORKDIR /app
RUN apk add --no-cache git python3 make g++
COPY ./indexer /app
RUN npm ci --unsafe-perm
RUN npm run build

FROM node:18-alpine
WORKDIR /app
RUN addgroup -S app && adduser -S app -G app
COPY --from=builder /app/dist /app/dist
COPY --from=builder /app/package.json /app/package.json
RUN chown -R app:app /app
USER app
ENV NODE_ENV=production
ENV PORT=4000
EXPOSE 4000
CMD ["node", "dist/index.js"]
DOCKERINDEX

cat > "$ROOT/infra/docker/api.Dockerfile" <<'DOCKERAPI'
FROM node:18-alpine AS builder
WORKDIR /app
RUN apk add --no-cache python3 make g++
COPY ./apps/api /app
RUN npm ci
RUN npm run build

FROM node:18-alpine
WORKDIR /app
RUN addgroup -S apz && adduser -S apz -G apz
COPY --from=builder /app/dist /app/dist
COPY --from=builder /app/package.json /app/package.json
COPY --from=builder /app/prisma /app/prisma
RUN chown -R apz:apz /app
USER apz
ENV NODE_ENV=production
ENV PORT=8080
EXPOSE 8080
CMD ["node", "dist/server.js"]
DOCKERAPI

# docker-compose devnet
cat > "$ROOT/infra/devnet/docker-compose.yml" <<'DC'
version: "3.8"
services:
  apz-node:
    image: apz/node:dev
    container_name: apz-node
    restart: unless-stopped
    environment:
      - CHAIN_ID=apz-testnet-1
      - NODE_MONIKER=apz-node-1
    ports:
      - "26656:26656"
      - "26657:26657"
    volumes:
      - ./data/apz-node:/var/lib/apz
    command: ["start"]

  apz-indexer:
    image: apz/indexer:dev
    container_name: apz-indexer
    restart: unless-stopped
    depends_on:
      - apz-node
    environment:
      - API_URL=http://apz-node:26657
    ports:
      - "4000:4000"
    volumes:
      - ./data/apz-indexer:/var/lib/apz-indexer

  apz-api:
    image: apz/api:dev
    container_name: apz-api
    restart: unless-stopped
    depends_on:
      - apz-indexer
    environment:
      - DATABASE_URL=postgres://postgres:password@apz-postgres:5432/apz
    ports:
      - "8080:8080"

  apz-postgres:
    image: postgres:14
    container_name: apz-postgres
    restart: unless-stopped
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=apz
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
DC

# Helm charts - node
cat > "$ROOT/infra/helm/node/Chart.yaml" <<'CH'
apiVersion: v2
name: apz-node
description: APZ Chain node Helm chart
version: 0.1.0
appVersion: "0.1.0"
CH

cat > "$ROOT/infra/helm/node/values.yaml" <<'NV'
replicaCount: 1
image:
  repository: ghcr.io/your-org/apz-node
  tag: latest
  pullPolicy: IfNotPresent

node:
  env:
    CHAIN_ID: apz-testnet-1
    NODE_MONIKER: apz-node
    APZ_HOME: /var/lib/apz
    MIN_GAS_PRICE: "0.0001apz"

persistence:
  enabled: true
  size: 20Gi
  storageClass: ""

resources:
  requests:
    cpu: "500m"
    memory: "1Gi"
  limits:
    cpu: "2000m"
    memory: "4Gi"

service:
  type: ClusterIP
  port: 26657

livenessProbe:
  initialDelaySeconds: 10
  periodSeconds: 20

readinessProbe:
  initialDelaySeconds: 10
  periodSeconds: 10
NV

cat > "$ROOT/infra/helm/node/templates/configmap.yaml" <<'CM'
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "apz-node.fullname" . }}-config
data:
  apz.env: |
    CHAIN_ID={{ .Values.node.env.CHAIN_ID }}
    NODE_MONIKER={{ .Values.node.env.NODE_MONIKER }}
    APZ_HOME={{ .Values.node.env.APZ_HOME }}
    MIN_GAS_PRICE={{ .Values.node.env.MIN_GAS_PRICE }}
CM

cat > "$ROOT/infra/helm/node/templates/secret.yaml" <<'SN'
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "apz-node.fullname" . }}-secrets
type: Opaque
stringData:
  NODE_KEY: ""
  PRIV_VALIDATOR_KEY: ""
SN

cat > "$ROOT/infra/helm/node/templates/deployment.yaml" <<'DEP'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "apz-node.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "apz-node.name" . }}
  template:
    metadata:
      labels:
        app: {{ include "apz-node.name" . }}
    spec:
      containers:
        - name: apz-node
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: 26656
            - containerPort: 26657
          envFrom:
            - configMapRef:
                name: {{ include "apz-node.fullname" . }}-config
            - secretRef:
                name: {{ include "apz-node.fullname" . }}-secrets
          env:
            - name: APZ_HOME
              value: {{ .Values.node.env.APZ_HOME | quote }}
            - name: MIN_GAS_PRICE
              value: {{ .Values.node.env.MIN_GAS_PRICE | quote }}
          volumeMounts:
            - name: data
              mountPath: /var/lib/apz
            - name: priv-keys
              mountPath: /etc/apz/keys
              readOnly: true
          readinessProbe:
            httpGet:
              path: /status
              port: 26657
            initialDelaySeconds: {{ .Values.readinessProbe.initialDelaySeconds }}
            periodSeconds: {{ .Values.readinessProbe.periodSeconds }}
          livenessProbe:
            httpGet:
              path: /status
              port: 26657
            initialDelaySeconds: {{ .Values.livenessProbe.initialDelaySeconds }}
            periodSeconds: {{ .Values.livenessProbe.periodSeconds }}
          resources:
            requests:
              cpu: {{ .Values.resources.requests.cpu }}
              memory: {{ .Values.resources.requests.memory }}
            limits:
              cpu: {{ .Values.resources.limits.cpu }}
              memory: {{ .Values.resources.limits.memory }}
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: {{ include "apz-node.fullname" . }}-pvc
        - name: priv-keys
          secret:
            secretName: {{ include "apz-node.fullname" . }}-secrets
DEP

cat > "$ROOT/infra/helm/node/templates/pvc.yaml" <<'PVCN'
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{ include "apz-node.fullname" . }}-pvc
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: {{ .Values.persistence.size }}
  storageClassName: {{ default "" .Values.persistence.storageClass }}
PVCN

cat > "$ROOT/infra/helm/node/templates/service.yaml" <<'SVCN'
apiVersion: v1
kind: Service
metadata:
  name: {{ include "apz-node.fullname" . }}
spec:
  type: {{ .Values.service.type | default "ClusterIP" }}
  ports:
    - name: rpc
      port: 26657
      targetPort: 26657
    - name: p2p
      port: 26656
      targetPort: 26656
  selector:
    app: {{ include "apz-node.name" . }}
SVCN

# Helm charts - indexer
cat > "$ROOT/infra/helm/indexer/Chart.yaml" <<'CIX'
apiVersion: v2
name: apz-indexer
description: APZ Indexer chart
version: 0.1.0
appVersion: "0.1.0"
CIX

cat > "$ROOT/infra/helm/indexer/values.yaml" <<'VIX'
replicaCount: 1
image:
  repository: ghcr.io/your-org/apz-indexer
  tag: latest
  pullPolicy: IfNotPresent
service:
  port: 4000
resources:
  requests:
    cpu: "250m"
    memory: "256Mi"
  limits:
    cpu: "500m"
    memory: "512Mi"
env:
  API_URL: "http://apz-node:26657"
  DATABASE_URL: "postgres://postgres:password@apz-postgres:5432/apz"
persistence:
  enabled: true
  size: 5Gi
  storageClass: ""
VIX

cat > "$ROOT/infra/helm/indexer/templates/configmap.yaml" <<'CIM'
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "apz-indexer.fullname" . }}-config
data:
  INDEXER_CONFIG: |
    {
      "rpcUrl": "{{ .Values.env.API_URL }}",
      "indexerInterval": 5
    }
CIM

cat > "$ROOT/infra/helm/indexer/templates/secret.yaml" <<'SIM'
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "apz-indexer.fullname" . }}-secrets
type: Opaque
stringData:
  DATABASE_URL: "{{ .Values.env.DATABASE_URL }}"
SIM

cat > "$ROOT/infra/helm/indexer/templates/deployment.yaml" <<'DIX'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "apz-indexer.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "apz-indexer.name" . }}
  template:
    metadata:
      labels:
        app: {{ include "apz-indexer.name" . }}
    spec:
      containers:
        - name: apz-indexer
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: {{ .Values.service.port }}
          env:
            - name: API_URL
              valueFrom:
                configMapKeyRef:
                  name: {{ include "apz-indexer.fullname" . }}-config
                  key: rpcUrl
          envFrom:
            - secretRef:
                name: {{ include "apz-indexer.fullname" . }}-secrets
          volumeMounts:
            - name: data
              mountPath: /var/lib/apz-indexer
          readinessProbe:
            httpGet:
              path: /health
              port: {{ .Values.service.port }}
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health
              port: {{ .Values.service.port }}
            initialDelaySeconds: 15
            periodSeconds: 20
          resources:
            requests:
              cpu: {{ .Values.resources.requests.cpu }}
              memory: {{ .Values.resources.requests.memory }}
            limits:
              cpu: {{ .Values.resources.limits.cpu }}
              memory: {{ .Values.resources.limits.memory }}
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: {{ include "apz-indexer.fullname" . }}-pvc
DIX

cat > "$ROOT/infra/helm/indexer/templates/pvc.yaml" <<'PVCIX'
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{ include "apz-indexer.fullname" . }}-pvc
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: {{ .Values.persistence.size }}
  storageClassName: {{ default "" .Values.persistence.storageClass }}
PVCIX

cat > "$ROOT/infra/helm/indexer/templates/service.yaml" <<'SIX'
apiVersion: v1
kind: Service
metadata:
  name: {{ include "apz-indexer.fullname" . }}
spec:
  type: ClusterIP
  ports:
    - port: {{ .Values.service.port }}
      targetPort: {{ .Values.service.port }}
      protocol: TCP
      name: http
  selector:
    app: {{ include "apz-indexer.name" . }}
SIX

# Helm charts - api
cat > "$ROOT/infra/helm/api/Chart.yaml" <<'CAP'
apiVersion: v2
name: apz-api
description: APZ API chart
version: 0.1.0
appVersion: "0.1.0"
CAP

cat > "$ROOT/infra/helm/api/values.yaml" <<'VAP'
replicaCount: 2
image:
  repository: ghcr.io/your-org/apz-api
  tag: latest
  pullPolicy: IfNotPresent

service:
  port: 8080

resources:
  requests:
    cpu: "250m"
    memory: "256Mi"
  limits:
    cpu: "1000m"
    memory: "1Gi"

env:
  DATABASE_URL: "postgres://postgres:password@apz-postgres:5432/apz"
  REDIS_URL: "redis://apz-redis:6379"
  JWT_SECRET: "replace-with-secure-secret"

ingress:
  enabled: false
  host: api.apz.example
  annotations: {}
persistence:
  enabled: false
VAP

cat > "$ROOT/infra/helm/api/templates/configmap.yaml" <<'CAM'
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "apz-api.fullname" . }}-config
data:
  APP_ENV: production
CAM

cat > "$ROOT/infra/helm/api/templates/secret.yaml" <<'SAM'
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "apz-api.fullname" . }}-secrets
type: Opaque
stringData:
  DATABASE_URL: "{{ .Values.env.DATABASE_URL }}"
  REDIS_URL: "{{ .Values.env.REDIS_URL }}"
  JWT_SECRET: "{{ .Values.env.JWT_SECRET }}"
SAM

cat > "$ROOT/infra/helm/api/templates/deployment.yaml" <<'DAP'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "apz-api.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "apz-api.name" . }}
  template:
    metadata:
      labels:
        app: {{ include "apz-api.name" . }}
    spec:
      containers:
        - name: apz-api
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: {{ .Values.service.port }}
          envFrom:
            - configMapRef:
                name: {{ include "apz-api.fullname" . }}-config
            - secretRef:
                name: {{ include "apz-api.fullname" . }}-secrets
          readinessProbe:
            httpGet:
              path: /health
              port: {{ .Values.service.port }}
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health
              port: {{ .Values.service.port }}
            initialDelaySeconds: 15
            periodSeconds: 20
          resources:
            requests:
              cpu: {{ .Values.resources.requests.cpu }}
              memory: {{ .Values.resources.requests.memory }}
            limits:
              cpu: {{ .Values.resources.limits.cpu }}
              memory: {{ .Values.resources.limits.memory }}
DAP

cat > "$ROOT/infra/helm/api/templates/service.yaml" <<'SAP'
apiVersion: v1
kind: Service
metadata:
  name: {{ include "apz-api.fullname" . }}
spec:
  type: ClusterIP
  ports:
    - port: {{ .Values.service.port }}
      targetPort: {{ .Values.service.port }}
      protocol: TCP
      name: http
  selector:
    app: {{ include "apz-api.name" . }}
SAP

cat > "$ROOT/infra/helm/api/templates/ingress.yaml" <<'IAP'
{{- if .Values.ingress.enabled }}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "apz-api.fullname" . }}
  annotations:
    {{- range $k, $v := .Values.ingress.annotations }}
    {{ $k }}: {{ $v | quote }}
    {{- end }}
spec:
  rules:
    - host: {{ .Values.ingress.host | quote }}
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: {{ include "apz-api.fullname" . }}
                port:
                  number: {{ .Values.service.port }}
{{- end }}
IAP

# Scripts
cat > "$ROOT/scripts/generate-genesis.sh" <<'GG'
#!/usr/bin/env bash
set -euo pipefail

CHAIN_ID="${CHAIN_ID:-apz-testnet-1}"
GENESIS_TIME="${GENESIS_TIME:-$(date -u +"%Y-%m-%dT%H:%M:%SZ")}"
OUT_DIR="${OUT_DIR:-./build/genesis}"
VALIDATOR_COUNT="${VALIDATOR_COUNT:-1}"

mkdir -p "$OUT_DIR"

cat > "$OUT_DIR/genesis.json" <<EOF
{
  "chain_id": "$CHAIN_ID",
  "genesis_time": "$GENESIS_TIME",
  "consensus_params": {
    "block": { "max_bytes": "22020096", "max_gas": "-1", "time_iota_ms": "1000" },
    "evidence": { "max_age_num_blocks": "100000", "max_age_duration": "172800000000000" },
    "validator": { "pub_key_types": ["ed25519"] }
  },
  "validators": [],
  "app_state": {
    "bank": { "balances": [] },
    "staking": { "params": { "unbonding_time": "1814400000000000", "max_validators": 100 } },
    "gov": { "deposit_params": { "min_deposit": [{ "denom": "apz", "amount": "1000000000000000000" }] } },
    "supply": { "total": [{ "denom": "apz", "amount": "1000000000000000000000000000" }] }
  }
}
EOF

echo "genesis.json created at $OUT_DIR/genesis.json"
GG
chmod +x "$ROOT/scripts/generate-genesis.sh"

cat > "$ROOT/scripts/bootstrap-validator.sh" <<'BV'
#!/usr/bin/env bash
set -euo pipefail

OUT_DIR="${OUT_DIR:-./build/genesis}"
VAL_NAME="${1:-validator-1}"
KEY_DIR="${KEY_DIR:-./priv}"
CHAIN_ID_FILE="${OUT_DIR}/genesis.json"

mkdir -p "$KEY_DIR" "$OUT_DIR"

echo "Bootstrapping validator: $VAL_NAME"
openssl genpkey -algorithm ed25519 -out "${KEY_DIR}/${VAL_NAME}_key.pem" || true
PUBKEY_BASE64=$(openssl pkey -pubout -in "${KEY_DIR}/${VAL_NAME}_key.pem" -outform PEM 2>/dev/null | tail -n +2 | head -n -1 | tr -d '\n' | base64 -w 0 || echo "REPLACE_BASE64_PUBKEY_${VAL_NAME}")

jq --arg addr "REPLACE_VALIDATOR_ADDRESS_${VAL_NAME}" \
   --arg pubkey "$PUBKEY_BASE64" \
   --arg name "$VAL_NAME" \
   '.validators += [ { "address": $addr, "pub_key": { "type": "tendermint/PubKeyEd25519", "value": $pubkey }, "power": "1000", "name": $name } ]' \
   "$CHAIN_ID_FILE" > "${CHAIN_ID_FILE}.tmp" && mv "${CHAIN_ID_FILE}.tmp" "$CHAIN_ID_FILE"

echo "Validator entry added to $CHAIN_ID_FILE"
BV
chmod +x "$ROOT/scripts/bootstrap-validator.sh"

cat > "$ROOT/scripts/helm-bootstrap.sh" <<'HB'
#!/usr/bin/env bash
set -euo pipefail
NAMESPACE="${1:-apz}"
kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
helm repo add apz-local http://example.com/charts || true
helm install apz-node ./infra/helm/node -n "$NAMESPACE" --create-namespace --wait || helm upgrade --install apz-node ./infra/helm/node -n "$NAMESPACE" --wait
helm install apz-indexer ./infra/helm/indexer -n "$NAMESPACE" --wait || helm upgrade --install apz-indexer ./infra/helm/indexer -n "$NAMESPACE" --wait
helm install apz-api ./infra/helm/api -n "$NAMESPACE" --wait || helm upgrade --install apz-api ./infra/helm/api -n "$NAMESPACE" --wait
echo "Helm bootstrap completed in namespace $NAMESPACE"
HB
chmod +x "$ROOT/scripts/helm-bootstrap.sh"

cat > "$ROOT/scripts/bootstrap-all.sh" <<'BA'
#!/usr/bin/env bash
set -euo pipefail

# scripts/bootstrap-all.sh
NAMESPACE="${NAMESPACE:-apz}"
REGISTRY="${REGISTRY:-ghcr.io/your-org}"
NODE_IMAGE_TAG="${NODE_IMAGE_TAG:-latest}"
INDEXER_IMAGE_TAG="${INDEXER_IMAGE_TAG:-latest}"
API_IMAGE_TAG="${API_IMAGE_TAG:-latest}"

DB_URL="${DB_URL:-postgres://postgres:password@apz-postgres:5432/apz}"
REDIS_URL="${REDIS_URL:-redis://apz-redis:6379}"
JWT_SECRET="${JWT_SECRET:-$(head -c 32 /dev/urandom | base64)}"

NODE_PRIV_KEY_FILE="${NODE_PRIV_KEY_FILE:-./priv/priv_validator.json}"
NODE_KEY_FILE="${NODE_KEY_FILE:-./priv/node_key.json}"

command -v kubectl >/dev/null 2>&1 || { echo "kubectl missing"; exit 1; }
command -v helm >/dev/null 2>&1 || { echo "helm missing"; exit 1; }

kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

if [ -n "${REGISTRY_USER:-}" ] && [ -n "${REGISTRY_PASS:-}" ]; then
  kubectl create secret docker-registry apz-registry-secret \
    --docker-server="${REGISTRY%%/*}" \
    --docker-username="$REGISTRY_USER" \
    --docker-password="$REGISTRY_PASS" \
    -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
fi

kubectl create secret generic apz-api-secrets \
  --from-literal=DATABASE_URL="$DB_URL" \
  --from-literal=REDIS_URL="$REDIS_URL" \
  --from-literal=JWT_SECRET="$JWT_SECRET" \
  -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

kubectl create secret generic apz-indexer-secrets \
  --from-literal=DATABASE_URL="$DB_URL" \
  -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

if [ -f "$NODE_PRIV_KEY_FILE" ] || [ -f "$NODE_KEY_FILE" ]; then
  kubectl create secret generic apz-node-secrets \
    --from-file=PRIV_VALIDATOR_KEY="$NODE_PRIV_KEY_FILE" \
    --from-file=NODE_KEY="$NODE_KEY_FILE" \
    -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
else
  kubectl create secret generic apz-node-secrets \
    --from-literal=PRIV_VALIDATOR_KEY="" \
    --from-literal=NODE_KEY="" \
    -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
fi

helm upgrade --install apz-node infra/helm/node -n "$NAMESPACE" --set image.repository="${REGISTRY}/apz-node" --set image.tag="${NODE_IMAGE_TAG}" --wait
helm upgrade --install apz-indexer infra/helm/indexer -n "$NAMESPACE" --set image.repository="${REGISTRY}/apz-indexer" --set image.tag="${INDEXER_IMAGE_TAG}" --wait
helm upgrade --install apz-api infra/helm/api -n "$NAMESPACE" --set image.repository="${REGISTRY}/apz-api" --set image.tag="${API_IMAGE_TAG}" --wait

kubectl rollout status deployment/apz-api -n "$NAMESPACE" --timeout=120s || true
kubectl rollout status deployment/apz-indexer -n "$NAMESPACE" --timeout=120s || true
kubectl rollout status deployment/apz-node -n "$NAMESPACE" --timeout=120s || true

kubectl get pods -n "$NAMESPACE"
BA
chmod +x "$ROOT/scripts/bootstrap-all.sh"

# systemd unit
cat > "$ROOT/systemd/apz-node.service" <<'UNIT'
[Unit]
Description=APZ Chain Node
After=network-online.target
Wants=network-online.target

[Service]
User=apz
Group=apz
EnvironmentFile=/etc/apz/apz.env
ExecStart=/usr/local/bin/apz-node start --home ${APZ_HOME:-/var/lib/apz} --pruning ${APZ_PRUNING:-syncable} --minimum-gas-prices "${MIN_GAS_PRICE:-0.0001apz}"
WorkingDirectory=${APZ_HOME:-/var/lib/apz}
Restart=on-failure
RestartSec=5
LimitNOFILE=65536
LimitNPROC=4096
TimeoutStartSec=300
ProtectSystem=full
ProtectHome=yes
PrivateTmp=yes
NoNewPrivileges=yes

[Install]
WantedBy=multi-user.target
UNIT

# Contracts
cat > "$ROOT/contracts/APZToken.sol" <<'SOL'
 // SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract APZToken is ERC20, Ownable {
    uint8 private constant _DECIMALS = 18;

    constructor() ERC20("APZ Token", "APZ") {
        // initial supply zero; mint via owner (bridge/admin) or staking contract
    }

    function decimals() public pure override returns (uint8) {
        return _DECIMALS;
    }

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external onlyOwner {
        _burn(from, amount);
    }
}
SOL

cat > "$ROOT/contracts/Staking.sol" <<'SOL2'
 // SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./APZToken.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract Staking is Ownable {
    APZToken public token;

    struct StakeInfo {
        uint256 amount;
        uint256 since;
    }

    mapping(address => StakeInfo) public stakes;
    uint256 public totalStaked;
    uint256 public rewardRatePerYearBP = 500; // 5% = 500 basis points

    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 amount);

    constructor(address tokenAddress) {
        token = APZToken(tokenAddress);
    }

    function stake(uint256 amount) external {
        require(amount > 0, "amount=0");
        token.transferFrom(msg.sender, address(this), amount);
        _updateReward(msg.sender);
        stakes[msg.sender].amount += amount;
        if (stakes[msg.sender].since == 0) stakes[msg.sender].since = block.timestamp;
        totalStaked += amount;
        emit Staked(msg.sender, amount);
    }

    function unstake(uint256 amount) external {
        require(stakes[msg.sender].amount >= amount, "insufficient");
        _updateReward(msg.sender);
        stakes[msg.sender].amount -= amount;
        totalStaked -= amount;
        token.transfer(msg.sender, amount);
        emit Unstaked(msg.sender, amount);
    }

    function earned(address user) public view returns (uint256) {
        StakeInfo memory s = stakes[user];
        if (s.amount == 0 || s.since == 0) return 0;
        uint256 duration = block.timestamp - s.since;
        uint256 reward = (s.amount * rewardRatePerYearBP * duration) / (10000 * 365 days);
        return reward;
    }

    function claim() external {
        uint256 reward = earned(msg.sender);
        require(reward > 0, "no reward");
        stakes[msg.sender].since = block.timestamp;
        token.mint(msg.sender, reward);
        emit RewardPaid(msg.sender, reward);
    }

    function _updateReward(address user) internal {
    }

    function setRewardRateBP(uint256 bp) external onlyOwner {
        rewardRatePerYearBP = bp;
    }

    function rescueTokens(address to, uint256 amount) external onlyOwner {
        token.transfer(to, amount);
    }
}
SOL2

cat > "$ROOT/contracts/Governance.sol" <<'SOL3'
 // SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./Staking.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract Governance is Ownable {
    Staking public staking;

    enum ProposalState { Active, Passed, Failed, Executed }

    struct Proposal {
        uint256 id;
        address proposer;
        string metadata;
        uint256 yes;
        uint256 no;
        uint256 start;
        uint256 end;
        ProposalState state;
    }

    uint256 public proposalCount;
    mapping(uint256 => Proposal) public proposals;
    uint256 public minDuration = 1 days;

    event Proposed(uint256 id, address proposer);
    event Voted(uint256 id, address voter, uint256 weight, bool support);
    event Executed(uint256 id, bool passed);

    constructor(address stakingAddress) {
        staking = Staking(stakingAddress);
    }

    function propose(string calldata metadata, uint256 duration) external returns (uint256) {
        require(duration >= minDuration, "duration too short");
        proposalCount++;
        proposals[proposalCount] = Proposal({
            id: proposalCount,
            proposer: msg.sender,
            metadata: metadata,
            yes: 0,
            no: 0,
            start: block.timestamp,
            end: block.timestamp + duration,
            state: ProposalState.Active
        });
        emit Proposed(proposalCount, msg.sender);
        return proposalCount;
    }

    function vote(uint256 proposalId, bool support) external {
        Proposal storage p = proposals[proposalId];
        require(block.timestamp >= p.start && block.timestamp <= p.end, "voting closed");
        uint256 weight = staking.stakes(msg.sender).amount;
        require(weight > 0, "no stake");
        if (support) {
            p.yes += weight;
        } else {
            p.no += weight;
        }
        emit Voted(proposalId, msg.sender, weight, support);
    }

    function execute(uint256 proposalId) external {
        Proposal storage p = proposals[proposalId];
        require(block.timestamp > p.end, "voting ongoing");
        require(p.state == ProposalState.Active, "already executed");
        if (p.yes > p.no) {
            p.state = ProposalState.Passed;
            emit Executed(proposalId, true);
        } else {
            p.state = ProposalState.Failed;
            emit Executed(proposalId, false);
        }
    }

    function setMinDuration(uint256 d) external onlyOwner {
        minDuration = d;
    }
}
SOL3

# Contracts Hardhat scaffold
cat > "$ROOT/contracts/package.json" <<'PKG'
{
  "name": "apz-contracts",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "test": "hardhat test --network hardhat",
    "coverage": "hardhat coverage",
    "clean": "rm -rf cache/ artifacts/",
    "compile": "hardhat compile"
  },
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^3.0.0",
    "@nomiclabs/hardhat-ethers": "^3.0.0",
    "chai": "^4.3.7",
    "ethereum-waffle": "^3.4.4",
    "ethers": "^6.9.0",
    "hardhat": "^2.16.0",
    "solidity-coverage": "^0.8.4"
  }
}
PKG

cat > "$ROOT/contracts/hardhat.config.js" <<'HHC'
require("dotenv").config();
require("@nomicfoundation/hardhat-toolbox");
require("solidity-coverage");

module.exports = {
  solidity: {
    compilers: [{ version: "0.8.19" }]
  },
  networks: {
    hardhat: {
      chainId: 1337
    }
  },
  mocha: {
    timeout: 200000
  }
};
HHC

# Tests
cat > "$ROOT/contracts/test/token.test.js" <<'TT1'
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("APZToken", function () {
  let APZToken, apz, owner, alice, bob;

  beforeEach(async function () {
    [owner, alice, bob] = await ethers.getSigners();
    APZToken = await ethers.getContractFactory("APZToken");
    apz = await APZToken.deploy();
    await apz.waitForDeployment();
  });

  it("has correct name and symbol and decimals", async function () {
    expect(await apz.name()).to.equal("APZ Token");
    expect(await apz.symbol()).to.equal("APZ");
    expect(await apz.decimals()).to.equal(18);
  });

  it("owner can mint and burn", async function () {
    await apz.connect(owner).mint(alice.address, 1000n * 10n ** 18n);
    expect((await apz.balanceOf(alice.address)).toString()).to.equal((1000n * 10n ** 18n).toString());
    await apz.connect(owner).burn(alice.address, 500n * 10n ** 18n);
    expect((await apz.balanceOf(alice.address)).toString()).to.equal((500n * 10n ** 18n).toString());
  });

  it("non-owner cannot mint", async function () {
    await expect(apz.connect(alice).mint(alice.address, 1)).to.be.reverted;
  });
});
TT1

cat > "$ROOT/contracts/test/staking.test.js" <<'TT2'
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Staking", function () {
  let Token, Staking, token, staking, owner, alice, bob;
  const toWei = (n) => BigInt(n) * 10n ** 18n;

  beforeEach(async function () {
    [owner, alice, bob] = await ethers.getSigners();
    Token = await ethers.getContractFactory("APZToken");
    token = await Token.deploy();
    await token.waitForDeployment();

    Staking = await ethers.getContractFactory("Staking");
    staking = await Staking.deploy(token.target);
    await staking.waitForDeployment();

    await token.connect(owner).mint(alice.address, toWei(1000));
    await token.connect(owner).mint(bob.address, toWei(1000));
  });

  it("allows stake and unstake", async function () {
    await token.connect(alice).approve(staking.target, toWei(100));
    await staking.connect(alice).stake(toWei(100));
    expect((await staking.stakes(alice.address)).amount).to.equal(toWei(100));

    await ethers.provider.send("evm_increaseTime", [3600 * 24]);
    await ethers.provider.send("evm_mine");

    const reward = await staking.earned(alice.address);
    expect(reward).to.be.a("bigint");

    await staking.connect(alice).unstake(toWei(50));
    expect((await staking.stakes(alice.address)).amount).to.equal(toWei(50));
  });

  it("owner can set rewardRate", async function () {
    await staking.connect(owner).setRewardRateBP(600);
    expect((await staking.rewardRatePerYearBP()).toString()).to.equal("600");
  });
});
TT2

cat > "$ROOT/contracts/test/governance.test.js" <<'TT3'
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Governance", function () {
  let Token, Staking, Governance;
  let token, staking, gov, owner, alice;

  beforeEach(async function () {
    [owner, alice] = await ethers.getSigners();
    Token = await ethers.getContractFactory("APZToken");
    token = await Token.deploy();
    await token.waitForDeployment();

    Staking = await ethers.getContractFactory("Staking");
    staking = await Staking.deploy(token.target);
    await staking.waitForDeployment();

    Governance = await ethers.getContractFactory("Governance");
    gov = await Governance.deploy(staking.target);
    await gov.waitForDeployment();

    await token.connect(owner).mint(alice.address, 1000n * 10n ** 18n);
    await token.connect(alice).approve(staking.target, 100n * 10n ** 18n);
    await staking.connect(alice).stake(100n * 10n ** 18n);
  });

  it("creates and votes on proposal", async function () {
    const duration = 60;
    const tx = await gov.connect(alice).propose("QmFakeIpfsHash", duration);
    const receipt = await tx.wait();
    const pid = 1;
    await gov.connect(alice).vote(pid, true);
    await ethers.provider.send("evm_increaseTime", [duration + 1]);
    await ethers.provider.send("evm_mine");
    await gov.connect(alice).execute(pid);
    const p = await gov.proposals(pid);
    expect(p.state).to.not.equal(0);
  });
});
TT3

cat > "$ROOT/contracts/test/edgecases.test.js" <<'TED'
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Edge cases and invariants", function () {
  let Token, Staking, token, staking, owner, alice, bob;
  const toWei = (n) => BigInt(n) * 10n ** 18n;

  beforeEach(async function () {
    [owner, alice, bob] = await ethers.getSigners();
    Token = await ethers.getContractFactory("APZToken");
    token = await Token.deploy();
    await token.waitForDeployment();

    Staking = await ethers.getContractFactory("Staking");
    staking = await Staking.deploy(token.target);
    await staking.waitForDeployment();

    await token.connect(owner).mint(alice.address, toWei(1000));
    await token.connect(owner).mint(bob.address, toWei(1000));
  });

  it("rejects unstake more than staked", async function () {
    await token.connect(alice).approve(staking.target, toWei(100));
    await staking.connect(alice).stake(toWei(10));
    await expect(staking.connect(alice).unstake(toWei(20))).to.be.reverted;
  });

  it("stake 0 should revert", async function () {
    await token.connect(alice).approve(staking.target, toWei(1));
    await expect(staking.connect(alice).stake(0)).to.be.revertedWith("amount=0");
  });

  it("repeated claim resets timestamp and doesn't create negative balances", async function () {
    await token.connect(alice).approve(staking.target, toWei(100));
    await staking.connect(alice).stake(toWei(100));
    await ethers.provider.send("evm_increaseTime", [3600 * 24 * 30]);
    await ethers.provider.send("evm_mine");
    const before = await staking.earned(alice.address);
    expect(before).to.be.a("bigint");
    await staking.connect(alice).claim();
    const second = await staking.earned(alice.address);
    expect(second).to.equal(0n);
  });

  it("totalStaked invariant holds after multiple stakeholders", async function () {
    await token.connect(alice).approve(staking.target, toWei(200));
    await token.connect(bob).approve(staking.target, toWei(300));
    await staking.connect(alice).stake(toWei(100));
    await staking.connect(bob).stake(toWei(200));
    const s1 = await staking.stakes(alice.address);
    const s2 = await staking.stakes(bob.address);
    const total = (s1.amount) + (s2.amount);
    expect((await staking.totalStaked())).to.equal(total);
  });
});
TED

cat > "$ROOT/contracts/test/fuzz.test.js" <<'TFZ'
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Basic fuzzing scenario", function () {
  let Token, Staking, token, staking, owner, addrs;
  const toWei = (n) => BigInt(n) * 10n ** 18n;
  const rand = (max) => Math.floor(Math.random() * max);

  beforeEach(async function () {
    [owner, ...addrs] = await ethers.getSigners();
    Token = await ethers.getContractFactory("APZToken");
    token = await Token.deploy();
    await token.waitForDeployment();

    Staking = await ethers.getContractFactory("Staking");
    staking = await Staking.deploy(token.target);
    await staking.waitForDeployment();

    for (let i = 0; i < 6; i++) {
      await token.connect(owner).mint(addrs[i].address, toWei(1000));
      await token.connect(addrs[i]).approve(staking.target, toWei(1000));
    }
  });

  it("randomized stake/unstake operations maintain invariants", async function () {
    const ops = 200;
    for (let i = 0; i < ops; i++) {
      const idx = rand(6);
      const actor = addrs[idx];
      const action = rand(3);
      try {
        if (action === 0) {
          const amt = BigInt(rand(200) + 1) * 10n ** 18n;
          await staking.connect(actor).stake(amt);
        } else if (action === 1) {
          const userStake = (await staking.stakes(actor.address)).amount;
          if (userStake > 0n) {
            const max = Number(userStake / 10n ** 18n);
            const amt = BigInt(Math.max(1, rand(Math.max(1, max))) ) * 10n ** 18n;
            await staking.connect(actor).unstake(amt);
          }
        } else {
          await ethers.provider.send("evm_increaseTime", [rand(3600)]);
          await ethers.provider.send("evm_mine");
          try { await staking.connect(actor).claim(); } catch(e) {}
        }
      } catch (e) {
      }

      let sum = 0n;
      for (let j = 0; j < 6; j++) {
        sum += (await staking.stakes(addrs[j].address)).amount;
      }
      expect((await staking.totalStaked())).to.equal(sum);
    }
  }).timeout(300000);
});
TFZ

cat > "$ROOT/contracts/test/fuzz.seeded.test.js" <<'FZSD'
const { expect } = require("chai");
const { ethers } = require("hardhat");

// Simple seeded RNG (xorshift32) for deterministic CI runs
function XorShift32(seed) {
  let x = BigInt(seed) & 0xffffffffn;
  return () => {
    x ^= (x << 13n) & 0xffffffffn;
    x ^= (x >> 17n) & 0xffffffffn;
    x ^= (x << 5n) & 0xffffffffn;
    return Number(x & 0xffffffffn) / 4294967295;
  };
}

describe("Deterministic fuzzing scenario (seeded)", function () {
  let Token, Staking, token, staking, owner, addrs;
  const toWei = (n) => BigInt(n) * 10n ** 18n;

  beforeEach(async function () {
    [owner, ...addrs] = await ethers.getSigners();
    Token = await ethers.getContractFactory("APZToken");
    token = await Token.deploy();
    await token.waitForDeployment();

    const StakingFactory = await ethers.getContractFactory("Staking");
    staking = await StakingFactory.deploy(token.target);
    await staking.waitForDeployment();

    for (let i = 0; i < 6; i++) {
      await token.connect(owner).mint(addrs[i].address, toWei(1000));
      await token.connect(addrs[i]).approve(staking.target, toWei(1000));
    }
  });

  it("deterministic randomized stake/unstake operations maintain invariants", async function () {
    const SEED = Number(process.env.FUZZ_SEED || 123456789);
    const rnd = XorShift32(SEED);
    const ops = Number(process.env.FUZZ_OPS || 200);

    for (let i = 0; i < ops; i++) {
      const idx = Math.floor(rnd() * 6);
      const actor = addrs[idx];
      const action = Math.floor(rnd() * 3);
      try {
        if (action === 0) {
          const amt = BigInt(Math.max(1, Math.floor(rnd() * 200))) * 10n ** 18n;
          await staking.connect(actor).stake(amt);
        } else if (action === 1) {
          const userStake = (await staking.stakes(actor.address)).amount;
          if (userStake > 0n) {
            const max = Number(userStake / 10n ** 18n) || 1;
            const amt = BigInt(Math.max(1, Math.floor(rnd() * max))) * 10n ** 18n;
            await staking.connect(actor).unstake(amt);
          }
        } else {
          const jump = Math.floor(rnd() * 3600);
          await ethers.provider.send("evm_increaseTime", [jump]);
          await ethers.provider.send("evm_mine");
          try { await staking.connect(actor).claim(); } catch (e) {}
        }
      } catch (e) {}

      let sum = 0n;
      for (let j = 0; j < 6; j++) {
        sum += (await staking.stakes(addrs[j].address)).amount;
      }
      expect((await staking.totalStaked())).to.equal(sum);
    }
  }).timeout(300000);
});
FZSD

cat > "$ROOT/contracts/test/FuzzStaking.t.sol" <<'FZTS'
 // SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../APZToken.sol";
import "../Staking.sol";

contract FuzzStaking is Test {
    APZToken token;
    Staking staking;
    address alice;

    function setUp() public {
        token = new APZToken();
        staking = new Staking(address(token));
        alice = address(0xABCD);
        token.mint(alice, 1000 * 10 ** 18);
        vm.prank(alice);
        token.approve(address(staking), type(uint256).max);
    }

    function testFuzz_Stake(uint256 amt) public {
        vm.assume(amt > 0 && amt < 1e21);
        vm.prank(alice);
        staking.stake(amt);
        assert(staking.totalStaked() >= staking.stakes(alice).amount);
    }

    function testFuzz_UnstakeAndClaim(uint256 stakeAmt, uint256 unstakeAmt, uint256 skipTime) public {
        vm.assume(stakeAmt > 0 && stakeAmt < 1e21);
        vm.assume(unstakeAmt <= stakeAmt);
        vm.assume(skipTime < 365 days);
        vm.prank(alice);
        staking.stake(stakeAmt);
        vm.warp(block.timestamp + skipTime);
        vm.prank(alice);
        if (unstakeAmt > 0) staking.unstake(unstakeAmt);
        vm.prank(alice);
        try staking.claim() {} catch {}
        assert(staking.totalStaked() == staking.stakes(alice).amount);
    }
}
FZTS

cat > "$ROOT/contracts/.echidna.yaml" <<'ECHA'
testMode: true
contract: Staking
config:
  maxRuns: 2000
  verbosity: 1
  tests:
    - name: staking_invariants
      description: "Check staking invariants"
ECHA

# Contracts CI workflows
cat > "$ROOT/.github/workflows/contracts-ci.yml" <<'CIC'
name: Contracts CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./contracts
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
      - name: Install deps
        run: npm ci
      - name: Compile
        run: npm run compile
      - name: Run tests
        run: npm run test
      - name: Run solidity-coverage
        run: npm run coverage
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: contracts-coverage
          path: ./coverage

  slither:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./contracts
    steps:
      - uses: actions/checkout@v4
      - name: Run Slither (Docker)
        run: |
          docker run --rm -v "${{ github.workspace }}/contracts":/src -w /src \
          solidityslither/slither:latest slither . --json-results slither-report.json || true
      - name: Upload Slither report
        uses: actions/upload-artifact@v4
        with:
          name: slither-report
          path: ./contracts/slither-report.json

  coverage-upload:
    runs-on: ubuntu-latest
    needs: [test]
    defaults:
      run:
        working-directory: ./contracts
    steps:
      - uses: actions/checkout@v4
      - name: Download coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: contracts-coverage
          path: ./coverage
      - name: Upload to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage/**/coverage.json
          fail_ci_if_error: false
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
CIC

# Fuzz Foundry Echidna workflow
cat > "$ROOT/.github/workflows/fuzz-foundry-echidna.yml" <<'FFE'
name: Foundry & Echidna Fuzzing

on:
  workflow_dispatch:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Foundry
        run: |
          curl -L https://foundry.paradigm.xyz | bash
          ~/.foundry/bin/foundryup
      - name: Install Echidna
        run: |
          sudo apt-get update
          sudo apt-get install -y cabal-install ghc libffi-dev libgmp-dev make
          cabal update
          cabal install echidna --installdir=/usr/local/bin --overwrite-policy=always

  forge-fuzz:
    needs: setup
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./contracts
    steps:
      - uses: actions/checkout@v4
      - name: Use Foundry
        run: |
          export PATH="$HOME/.foundry/bin:$PATH"
          forge --version
      - name: Run forge tests
        run: |
          export PATH="$HOME/.foundry/bin:$PATH"
          forge test -v
      - name: Run forge fuzz (example)
        run: |
          export PATH="$HOME/.foundry/bin:$PATH"
          forge test --match-contract 'FuzzStaking' -vv
      - name: Upload forge results
        uses: actions/upload-artifact@v4
        with:
          name: forge-results
          path: ./contracts/test-results || true

  echidna-fuzz:
    needs: setup
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./contracts
    steps:
      - uses: actions/checkout@v4
      - name: Run Echidna fuzz
        run: |
          if ! command -v echidna-test >/dev/null 2>&1; then
            echo "echidna-test not found; ensure cabal install succeeded"
            exit 1
          fi
          echidna-test contracts/Staking.sol --contract Staking --configuration .echidna.yaml --test-mode
      - name: Upload Echidna report
        uses: actions/upload-artifact@v4
        with:
          name: echidna-report
          path: ./contracts/echidna-report || true
FFE

# Apps: API
cat > "$ROOT/apps/api/package.json" <<'APIPKG'
{
  "name": "apz-api",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "node src/server.js",
    "start": "node dist/server.js",
    "build": "npx babel src -d dist --copy-files",
    "test": "node tests/run.js",
    "lint": "eslint src || true"
  },
  "dependencies": {
    "express": "^4.18.2",
    "body-parser": "^1.20.2",
    "cors": "^2.8.5",
    "jsonwebtoken": "^9.0.0",
    "ethers": "^6.0.0",
    "pg": "^8.10.0",
    "knex": "^2.5.1",
    "dotenv": "^16.0.3"
  },
  "devDependencies": {
    "@babel/cli": "^7.22.5",
    "@babel/core": "^7.22.5",
    "@babel/preset-env": "^7.22.5",
    "eslint": "^8.44.0"
  }
}
APIPKG

cat > "$ROOT/apps/api/.env.example" <<'ENVAPI'
PORT=8080
DATABASE_URL=postgres://postgres:password@apz-postgres:5432/apz
JWT_SECRET=replace-with-secure-secret
RPC_URL=http://apz-node:26657
ENVAPI

cat > "$ROOT/apps/api/src/server.js" <<'APISRV'
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');
const { ethers } = require('ethers');

const app = express();
app.use(bodyParser.json());
app.use(require('cors')());

const PORT = process.env.PORT || 8080;
const JWT_SECRET = process.env.JWT_SECRET || 'dev_secret';

const tracks = {};
let trackIdCounter = 1;

const challenges = new Map();
app.post('/auth/challenge-request', (req, res) => {
  const { wallet_address } = req.body;
  if (!wallet_address) return res.status(400).json({ error: 'wallet required' });
  const challenge = `apz:${Date.now()}:${Math.random().toString(36).slice(2,9)}`;
  challenges.set(wallet_address.toLowerCase(), challenge);
  res.json({ challenge });
});

app.post('/auth/wallet-verify', async (req, res) => {
  const { wallet_address, signature } = req.body;
  if (!wallet_address || !signature) return res.status(400).json({ error: 'missing' });
  const challenge = challenges.get(wallet_address.toLowerCase());
  if (!challenge) return res.status(400).json({ error: 'no challenge' });
  try {
    const recovered = ethers.verifyMessage(challenge, signature);
    if (recovered.toLowerCase() !== wallet_address.toLowerCase()) {
      return res.status(401).json({ error: 'invalid signature' });
    }
    const token = jwt.sign({ wallet: wallet_address }, JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, user: { wallet_address } });
  } catch (err) {
    res.status(500).json({ error: 'verify error' });
  }
});

function auth(req, res, next) {
  const authz = req.headers.authorization;
  if (!authz) return res.status(401).json({ error: 'auth required' });
  const token = authz.split(' ')[1];
  try {
    const t = jwt.verify(token, JWT_SECRET);
    req.user = t;
    next();
  } catch (err) {
    res.status(401).json({ error: 'invalid token' });
  }
}

app.get('/tracks', (req, res) => {
  const list = Object.values(tracks);
  res.json({ data: list, meta: { total: list.length } });
});

app.post('/tracks', auth, (req, res) => {
  const { title, description, tags = [], visibility = 'public' } = req.body;
  const id = String(trackIdCounter++);
  tracks[id] = { id, owner: req.user.wallet, title, description, tags, visibility, created_at: new Date().toISOString() };
  res.status(201).json({ track: tracks[id] });
});

app.get('/tracks/:id', (req, res) => {
  const t = tracks[req.params.id];
  if (!t) return res.status(404).json({ error: 'not found' });
  res.json({ track: t });
});

const sessions = {};
let sessionIdCounter = 1;
app.post('/mining/session', auth, (req, res) => {
  const { track_id, action } = req.body;
  if (!track_id || !action) return res.status(400).json({ error: 'missing' });
  if (action === 'start') {
    const sid = String(sessionIdCounter++);
    sessions[sid] = { id: sid, user: req.user.wallet, track_id, start_at: Date.now(), end_at: null, reward_amount: 0 };
    return res.json({ session: sessions[sid] });
  } else if (action === 'end') {
    const sid = Object.keys(sessions).reverse().find(k => sessions[k].user === req.user.wallet && sessions[k].track_id === track_id && !sessions[k].end_at);
    if (!sid) return res.status(400).json({ error: 'no active session' });
    sessions[sid].end_at = Date.now();
    sessions[sid].reward_amount = 1;
    return res.json({ session: sessions[sid] });
  } else {
    return res.status(400).json({ error: 'bad action' });
  }
});

app.get('/health', (req, res) => res.json({ status: 'ok' }));

app.listen(PORT, () => console.log(`APZ API listening on ${PORT}`));
APISRV

# Indexer
cat > "$ROOT/apps/indexer/package.json" <<'IPKG'
{
  "name": "apz-indexer",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "node src/index.js",
    "build": "babel src -d dist --copy-files",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "axios": "^1.4.0",
    "pg": "^8.10.0",
    "dotenv": "^16.0.3",
    "p-retry": "^4.6.2"
  },
  "devDependencies": {
    "@babel/cli": "^7.22.5",
    "@babel/core": "^7.22.5",
    "@babel/preset-env": "^7.22.5"
  }
}
IPKG

cat > "$ROOT/apps/indexer/src/index.js" <<'IDX'
require('dotenv').config();
const axios = require('axios');

const RPC = process.env.RPC_URL || 'http://apz-node:26657';
const POLL_MS = Number(process.env.POLL_MS || 5000);

let lastHeight = 0;

async function fetchStatus() {
  const r = await axios.get(`${RPC}/status`);
  return r.data;
}

async function fetchBlock(height) {
  const r = await axios.get(`${RPC}/block?height=${height}`);
  return r.data;
}

async function mainLoop() {
  try {
    const status = await fetchStatus();
    const h = Number(status.result.sync_info.latest_block_height);
    if (h > lastHeight) {
      for (let i = lastHeight + 1; i <= h; i++) {
        try {
          const block = await fetchBlock(i);
          console.log('New block', i, block.result.block_id.hash);
        } catch (e) {
          console.error('fetchBlock error', i, e.message);
        }
      }
      lastHeight = h;
    }
  } catch (e) {
    console.error('status error', e.message);
  }
}

async function start() {
  console.log('APZ Indexer starting, RPC=', RPC);
  setInterval(mainLoop, POLL_MS);
}

start();
IDX

# Web app
cat > "$ROOT/apps/web/package.json" <<'WPKG'
{
  "name": "apz-web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "next": "13.4.10",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "ethers": "^6.0.0",
    "wagmi": "^1.5.0"
  }
}
WPKG

cat > "$ROOT/apps/web/pages/index.js" <<'WEBIDX'
import React, { useState } from 'react';
import { ethers } from 'ethers';

export default function Home() {
  const [address, setAddress] = useState('');
  const [tracks, setTracks] = useState([]);

  async function connect() {
    if (window.ethereum) {
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const addr = await signer.getAddress();
      setAddress(addr);
    } else {
      alert('Install MetaMask');
    }
  }

  async function loadTracks() {
    const res = await fetch('/api/tracks');
    const j = await res.json();
    setTracks(j.data || []);
  }

  return (
    <div style={{ padding: 24 }}>
      <h1>APZ Chain — DApp</h1>
      <button onClick={connect}>{address ? address : 'Connect Wallet'}</button>
      <button onClick={loadTracks} style={{ marginLeft: 8 }}>Load Tracks</button>
      <ul>
        {tracks.map(t => (
          <li key={t.id}>
            <strong>{t.title}</strong> — {t.owner}
          </li>
        ))}
      </ul>
    </div>
  );
}
WEBIDX

cat > "$ROOT/apps/web/pages/api/tracks.js" <<'WEBAPI'
import fetch from 'node-fetch';
export default async function handler(req, res) {
  const API_URL = process.env.API_URL || 'http://localhost:8080';
  const r = await fetch(`${API_URL}/tracks`);
  const j = await r.json();
  res.status(200).json(j);
}
WEBAPI

cat > "$ROOT/apps/web/README.md" <<'WREAD'
APZ web DApp scaffold
- dev: npm install && npm run dev
- env: set API_URL to point to running apz-api during development
- wallet: uses window.ethereum for connect; integrate wagmi/ethers for production
WREAD

# CI Workflows for images
cat > "$ROOT/.github/workflows/ci-ghcr.yml" <<'GHCR'
name: Build and Push Docker Images to GHCR

on:
  push:
    tags:
      - 'v*.*.*'
    branches:
      - main
      - develop
  workflow_dispatch:

env:
  IMAGE_PREFIX: ghcr.io/your-org
  NODE_IMAGE: ${{ env.IMAGE_PREFIX }}/apz-node
  INDEXER_IMAGE: ${{ env.IMAGE_PREFIX }}/apz-indexer
  API_IMAGE: ${{ env.IMAGE_PREFIX }}/apz-api

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v2
      - uses: docker/setup-buildx-action@v2
      - name: Login to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USERNAME }}
          password: ${{ secrets.GHCR_TOKEN }}
      - id: meta
        run: |
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" || "${GITHUB_REF##*/}" == v* ]]; then
            TAG=${GITHUB_REF##*/}
          else
            TAG=$(git rev-parse --short HEAD)
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
      - name: Build and push apz-node
        uses: docker/build-push-action@v4
        with:
          context: ./infra/docker
          file: infra/docker/node.Dockerfile
          push: true
          tags: |
            ${{ env.NODE_IMAGE }}:${{ steps.meta.outputs.tag }}
            ${{ env.NODE_IMAGE }}:latest
      - name: Build and push apz-indexer
        uses: docker/build-push-action@v4
        with:
          context: ./indexer
          file: infra/docker/indexer.Dockerfile
          push: true
          tags: |
            ${{ env.INDEXER_IMAGE }}:${{ steps.meta.outputs.tag }}
            ${{ env.INDEXER_IMAGE }}:latest
      - name: Build and push apz-api
        uses: docker/build-push-action@v4
        with:
          context: ./apps/api
          file: infra/docker/api.Dockerfile
          push: true
          tags: |
            ${{ env.API_IMAGE }}:${{ steps.meta.outputs.tag }}
            ${{ env.API_IMAGE }}:latest
GHCR

cat > "$ROOT/.github/workflows/ci-dockerhub.yml" <<'DOCH'
name: Build and Push Docker Images to DockerHub

on:
  push:
    tags:
      - 'v*.*.*'
    branches:
      - main
      - develop
  workflow_dispatch:

env:
  IMAGE_PREFIX: docker.io/your-org
  NODE_IMAGE: ${{ env.IMAGE_PREFIX }}/apz-node
  INDEXER_IMAGE: ${{ env.IMAGE_PREFIX }}/apz-indexer
  API_IMAGE: ${{ env.IMAGE_PREFIX }}/apz-api

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v2
      - uses: docker/setup-buildx-action@v2
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - id: meta
        run: |
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" || "${GITHUB_REF##*/}" == v* ]]; then
            TAG=${GITHUB_REF##*/}
          else
            TAG=$(git rev-parse --short HEAD)
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
      - name: Build and push apz-node
        uses: docker/build-push-action@v4
        with:
          context: ./infra/docker
          file: infra/docker/node.Dockerfile
          push: true
          tags: |
            ${{ env.NODE_IMAGE }}:${{ steps.meta.outputs.tag }}
            ${{ env.NODE_IMAGE }}:latest
      - name: Build and push apz-indexer
        uses: docker/build-push-action@v4
        with:
          context: ./indexer
          file: infra/docker/indexer.Dockerfile
          push: true
          tags: |
            ${{ env.INDEXER_IMAGE }}:${{ steps.meta.outputs.tag }}
            ${{ env.INDEXER_IMAGE }}:latest
      - name: Build and push apz-api
        uses: docker/build-push-action@v4
        with:
          context: ./apps/api
          file: infra/docker/api.Dockerfile
          push: true
          tags: |
            ${{ env.API_IMAGE }}:${{ steps.meta.outputs.tag }}
            ${{ env.API_IMAGE }}:latest
DOCH

# Fuzz/Foundry/Echidna files already created above (FuzzStaking.t.sol and .echidna.yaml)
# Finalize: make scripts executable
chmod +x "$ROOT/scripts/"*.sh || true

# Zip
echo "Creating ZIP $OUT_ZIP"
rm -f "$OUT_ZIP"
cd "$ROOT/.."
zip -r "../$OUT_ZIP" "$(basename "$ROOT")" -x "*.git/*" -x "*node_modules/*"
cd - >/dev/null

echo "Created $OUT_ZIP in $(pwd)"
ls -lh "$OUT_ZIP"